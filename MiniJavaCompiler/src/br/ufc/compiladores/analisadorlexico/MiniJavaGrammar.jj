/**
 * JavaCC template file created by SF JavaCC plugin 1.5.17+ wizard for JavaCC 1.5.0+
 */options{  JDK_VERSION = "1.5";  static = true;}PARSER_BEGIN(MiniJavaParser)package br.ufc.compiladores.analisadorlexico;

import java.io.FileInputStream;
import java.io.IOException;
import br.ufc.compiladores.sintaxeabstrata.*;

public class MiniJavaParser{  public static void main(String args []) throws ParseException, IOException  {
	    FileInputStream fileInputStream = new FileInputStream("JavaFiles/teste.java");      MiniJavaParser parser = new MiniJavaParser(fileInputStream);
    System.out.println("Lendo arquivo teste.java, do diretório ../JavaFiles");
        try    {      MiniJavaParser.program();      System.out.println("OK!");    }    catch (Exception e)    {      System.out.println("NOK.");      System.out.println(e.getMessage());    }    catch (Error e)    {      System.out.println("Oops.");      System.out.println(e.getMessage());    }  }}PARSER_END(MiniJavaParser)SKIP :
{
  < "/" "/" ( ~[ "\n", "\r" ] )* ( "\n" | "\r" | "\r\n" ) >
| < "/" "*" ( ~[ "*" ] | "*" ~[ "/" ] )* "*/" >
| " "
| "\r"
| "\r\n"
| "\n"
| "\t"
}

TOKEN : /* Operadores e Simbolos */
{
  < PLUS : "+" >
| < AND : "&&" >
| < LESSTHAN :"<" >
| < MINUS : "-" >
| < MULTIPLY : "*" >
| < NOT : "!" >
| < SEMICOLON : ";" >
| < COMMA : "," >
| < DOT : "." >
| < EQUAL: "=" >
| < LBRACKET : "[" >
| < RBRACKET : "]" >
| < LBRACES : "{" >
| < RBRACES : "}" >
| < LPAREN : "(" >
| < RPAREN : ")" >
| < ULINE : "_" >
}

TOKEN : /* Palavras Reservadas */
{
  < PUBLIC : "public" >
| < STATIC : "static" >
| < TRUE : "true" >
| < FALSE : "false" >
| < VOID : "void" >
| < MAIN : "main" >
| < EXTENDS : "extends" >
| < RETURN : "return" >
| < IF : "if" >
| < ELSE: "else" >
| < WHILE: "while" >
| < SYSOUT: "System.out.println" >
| < CLASS: "class" >
| < THIS: "this" >
| < NEW: "new" >
| < LENGTH: "length" >
| < STRING: "String" >
}

TOKEN : /* Tipos */
{
  	< INT : "int" >
| < INTARRAY : "int[]" >
| < BOOLEAN : "boolean" >
}

TOKEN :
{
  < #LETTER : ["a" - "z"] | ["A" - "Z"] >
| < #DIGIT : ["0" - "9"] >
| < INT_LITERAL: (< DIGIT >)+ >| < ID: < LETTER > (< LETTER > | < ULINE > | < DIGIT >)* >
}
Program program() :
{
  MainClass main; 
  ClassDecl classDeclaration;
  ClassDeclList classList = new ClassDeclList();
}
{
  main=mainClass() 
  (
    classDeclaration=classDeclaration() { classList.addElement(classDeclaration); }
  )*
  { return new Program(main, classList); }
}

MainClass mainClass() :
{
  Statement statement;
  String classId, argsId;
}
{
  < CLASS > classId=< ID > < LBRACES > < PUBLIC > < STATIC > < VOID > < MAIN > < LPAREN > < STRING > < LBRACKET > < RBRACKET > argsId=< ID > < RPAREN > < LBRACES >
  statement=statement() < RBRACES >
  < RBRACES >
  {    return new MainClass(statement, new Identifier(classId), new Identifier(argsId));
  }
}

ClassDecl classDeclaration() :
{
  String classId;
  ClassDecl classDeclaration;
}
{
  < CLASS > classId=< ID > classDeclaration=classDeclarationTail(classId)
  {
    return classDeclaration;
  }
}

ClassDecl classDeclarationTail(String classId) :
{
  String superId;
  VarDeclList vars = new VarDeclList();
  MethodDeclList methods = new MethodDeclList();
  VarDecl var;
  MethodDecl method;
}
{
  ( 
  < LBRACES >
  (
    var=varDeclaration() { vars.addElement(var); }  
  )*
  (
    method=methodDeclaration() { methods.addElement(method); }
  )* < RBRACES >
  
  { return new ClassDeclSimple(classId, vars, methods); }
  
  )
| (
  < EXTENDS > superId=< ID > < LBRACES >
  (
    var=varDeclaration() { vars.addElement(var); }  
  )*
  (
    method=methodDeclaration() { methods.addElement(method); }
  )* < RBRACES >
  
  { return new ClassDeclExtends(classId, superId, vars, methods); }
  )
}

VarDecl varDeclaration() :
{
  String typeId;
  String varId;
  VarDecl var;
}
{
  (    typeId=< ID > varId=< ID > < SEMICOLON >
    { return new VarDecl(new IdentifierType(typeId), new Identifier(varId)); }
  )  
|  var=varDeclarationNoID() { return var; }
}

VarDecl varDeclarationNoID() :
{
  Type type;
  String varId;
}
{
  type=typeNoID() varId=< ID > < SEMICOLON >  { return new VarDecl(type, new Identifier(varId)); }
}

MethodDecl methodDeclaration() :
{
}
{
  < PUBLIC > type() < ID > < LPAREN > parameterList() < RPAREN > < LBRACES >
  methodLoop() < RETURN > expression() < SEMICOLON > < RBRACES >
}

void methodLoop() :
{}
{
  < ID > identifierStartedLine()
| varDeclarationNoID() methodLoop()
| statementNoID() ( statement() )*
| {}
}

void identifierStartedLine() :
{}
{
  < ID > < SEMICOLON > methodLoop() // caso em que o primeiro identificador é o tipo da variável
| identifierStartedStatement() ( statement() ) * // caso em que o primeiro identificador é parte de uma sentença. Não volta ao methodLoop porque não podem mais haver declarações de variáveis
}

void identifierStartedStatement() :
{}
{
  < EQUAL > expression() < SEMICOLON >
| < LBRACKET > expression() < RBRACKET > < EQUAL > expression() < SEMICOLON > 
}

void statement() :
{}
{
  < ID > identifierStartedStatement()
| statementNoID()
}

void parameterList() :
{}
{
  type() < ID > ( parameterListTail() )*
| {}
}

void parameterListTail() :
{}
{
  < COMMA > type() < ID >
}

void type() :
{}
{
  < ID >
| typeNoID()
}

void typeNoID() :
{}
{  < INT >
| < INTARRAY >
| < BOOLEAN >
// | < ID > esta produção não é incluida aqui porque é tratada no não-terminal methodLoop, para evitar conflitos.
}

void statementNoID() :
{}
{
  < LBRACES > ( statement() )* < RBRACES >
| < IF > < LPAREN > expression() < RPAREN > statement() < ELSE > statement()
| < WHILE > < LPAREN > expression() < RPAREN > statement()
| < SYSOUT > < LPAREN > expression() < RPAREN > < SEMICOLON >
// As produções iniciando com < ID > não são incluidas aqui  porque são tratadas no não-terminal methodLoop, para evitar conflitos.
}

void expression() :
{}
{
 < INT_LITERAL > expressionRecursion()
| < TRUE > expressionRecursion()
| < FALSE > expressionRecursion()
| < ID > expressionRecursion() 
| < THIS > expressionRecursion()
| < NEW > newStartedExpression() expressionRecursion()
| < NOT > expression() expressionRecursion()
| < LPAREN > expression() < RPAREN > expressionRecursion()
}

void newStartedExpression() :
{}
{
  < INT > < LBRACKET > expression() < RBRACKET > 
| < ID > < LPAREN > < RPAREN > }

void expressionRecursion() :
{}
{
  operator() expression() expressionRecursion()
| < LBRACKET > expression() < RBRACKET > expressionRecursion()
| < DOT > dotStartedExpressionRecursion() expressionRecursion()
| {}}

void dotStartedExpressionRecursion() :
{}
{
  < LENGTH > 
| < ID > < LPAREN > expressionList() < RPAREN >}

void expressionList() :
{}
{  expression() ( expressionListTail() )*
| {}
}

void expressionListTail() :
{}
{  < COMMA > expression()
}

void operator() :
{}
{  < PLUS >
| < AND >
| < LESSTHAN > 
| < MINUS >
| < MULTIPLY >
}
