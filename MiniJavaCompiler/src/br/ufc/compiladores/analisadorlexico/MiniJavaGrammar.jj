/**
 * JavaCC template file created by SF JavaCC plugin 1.5.17+ wizard for JavaCC 1.5.0+
 */options{  JDK_VERSION = "1.5";  static = true;}PARSER_BEGIN(MiniJavaParser)package br.ufc.compiladores.analisadorlexico;

import java.io.FileInputStream;
import java.io.IOException;
import java.io.FileReader;

public class MiniJavaParser{  public static void main(String args []) throws ParseException, IOException  {
	FileInputStream fileInpuStream = new FileInputStream("teste.java");      MiniJavaParser parser = new MiniJavaParser(fileInpuStream);
        while (true)    {      System.out.println("Lendo arquivo .java, do diretório ../JavaFiles");      try      {        switch (MiniJavaParser.one_line())        {          case 0 :           System.out.println("OK.");          break;          case 1 :           System.out.println("Goodbye.");          break;          default :           break;        }      }      catch (Exception e)      {        System.out.println("NOK.");        System.out.println(e.getMessage());        MiniJavaParser.ReInit(System.in);      }      catch (Error e)      {        System.out.println("Oops.");        System.out.println(e.getMessage());        break;      }    }  }}PARSER_END(MiniJavaParser)SKIP :
{
  < "/" "/" ( ~[ "\n", "\r" ] )* ( "\n" | "\r" | "\r\n" ) >
| < "/" "*" ( ~[ "*" ] | "*" ~[ "/" ] )* "*/" >
| " "
| "\r"
| "\r\n"
| "\n"
}

TOKEN : /* Operadores e Simbolos */
{
  < PLUS : "+" >
| < AND : "&&" >
| < LESSTHAN :"<" >
| < MINUS : "-" >
| < MULTIPLY : "*" >
| < NOT : "!" >
| < SEMICOLON : ";" >
| < COMMA : "," >
| < DOT : "." >
| < EQUAL: "=" >
| < LBRACKET : "[" >
| < RBRACKET : "]" >
| < LBRACES : "{" >
| < RBRACES : "}" >
| < LPAREN : "(" >
| < RPAREN : ")" >
| < ULINE : "_" >
}

TOKEN : /* Palavras Reservadas */
{
  < PUBLIC : "public" >
| < STATIC : "static" >
| < TRUE : "true" >
| < FALSE : "false" >
| < VOID : "void" >
| < MAIN : "main" >
| < EXTENDS : "extends" >
| < RETURN : "return" >
| < IF : "if" >
| < ELSE: "else" >
| < WHILE: "while" >
| < SYSOUT: "System.out.println" >
| < CLASS: "class" >
| < THIS: "this" >
| < NEW: "new" >
| < LENGTH: "length" >
| < STRING: "String" >
}

TOKEN : /* Tipos */
{
  	< INT : "int" >
| < INTARRAY : "int[]" >
| < BOOLEAN : "boolean" >
}

TOKEN :
{
  < #LETTER : ["a" - "z"] | ["A" - "Z"] >
| < #DIGIT : ["0" - "9"] >
| < NUMBER: (< DIGIT >)+ >
| < ID: < LETTER > (< LETTER > | < ULINE > | < DIGIT >)+ >

}
int program() :
{}
{
  mainClass() ( classDeclaration() )*
}

void mainClass() :
{}
{
  < CLASS > < ID > < LBRACES > < PUBLIC > < STATIC > < VOID > < MAIN > < LPAREN > < STRING > < LBRACKET > < RBRACKET >
  statement() < RBRACES >
  < RBRACES >
}

void classDeclaration() :
{}
{
  < CLASS > < ID > classDeclarationBlock()
}

void classDeclarationBlock() :
{}
{
  < LBRACES >
  ( varDeclaration() )* ( methodDeclaration() )* < RBRACES >
| < EXTENDS > < ID > < LBRACES >
  ( varDeclaration() )* ( methodDeclaration() )* < RBRACES >
}

void varDeclaration() :
{}
{
  type() < ID > < SEMICOLON >
}

void methodDeclaration() :
{}
{
  < PUBLIC > type() < ID > < LPAREN > parameterList() < RPAREN > < LBRACES >
  methodLoop() < RETURN > expression() < SEMICOLON > < RBRACES >
}

void methodLoop() :
{}
{
  < ID > identifierStartedLine()
| varDeclaration() methodLoop()
| statement() statementLoop()
}

void identifierStartedLine() :
{}
{
  < ID > < SEMICOLON > methodLoop() // caso em que o primeiro identificador é o tipo da variável
| identifierStartedStatement() // caso em que o primeiro identificador é parte de uma sentença. Sai do method loop porque não podem mais haver declarações de variáveis
}

void identifierStartedStatement() :
{}
{
  < EQUAL > expression() < SEMICOLON > statementLoop()
| < LBRACKET > expression() < RBRACKET > < EQUAL > expression() < SEMICOLON > statementLoop()
}

void statementLoop() :
{}
{
  < ID > identifierStartedStatement()
| statement() statementLoop()
| {}
}

void parameterList() :
{}
{
  type() < ID > ( parameterListTail() )*
| {}
}

void parameterListTail() :
{}
{
  < COMMA > type() < ID >
}

void type() :
{}
{
  < INT >
| < INTARRAY >
| < BOOLEAN >
// | < ID > esta produção não é incluida aqui porque é tratada no não-terminal methodLoop, para evitar conflitos.
}

void statement() :
{}
{
  < LBRACES > ( statement() )* < RBRACES >
| < IF > < LPAREN > statement() < RPAREN > statement() < ELSE > statement()
| < WHILE > < LPAREN > expression() < RPAREN > statement()
| < SYSOUT > < LPAREN > expression() < RPAREN > < SEMICOLON >
// As produções iniciando com < ID > não são incluidas aqui  porque são tratadas no não-terminal methodLoop, para evitar conflitos.
}

void expression() : // TODO: continuar as produções da expressão, e implementar outros não terminais.
{}
{
  < NUMBER > < PLUS > < NUMBER >
}

//TODO: remover gramática do templete abaixo.
int one_line() :
{}
{
  sum() ";"
  {
    return 0;
  }
| ";"
  {
    return 1;
  }
}
void sum() :
{}
{
  term()
  (
    (
      < PLUS >
    | < MINUS >
    )
    term()
  )*
}

void term() :
{}
{
  unary()
  (
    (
      < MULTIPLY >
    )
    unary()
  )*
}

void unary() :
{}
{
  < MINUS > element()
| element()
}

void element() :
{}
{
  < NUMBER >
| "(" sum() ")"
}